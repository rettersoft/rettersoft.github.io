<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rettersoft.github.io/blog</id>
    <title>Retter Mobile Blog</title>
    <updated>2021-12-07T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rettersoft.github.io/blog"/>
    <subtitle>Retter Mobile Blog</subtitle>
    <icon>https://rettersoft.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[rtbs.io - An object oriented cloud]]></title>
        <id>an-object-oriented-cloud</id>
        <link href="https://rettersoft.github.io/blog/an-object-oriented-cloud"/>
        <updated>2021-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers.]]></summary>
        <content type="html"><![CDATA[<p>Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers. </p><p>However they allow you write stateless functions only. Data and functions are separated like in the early days of computing. rtbs.io is an object oriented approach to serverless cloud.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>I will give AWS specific examples in this article.</p><p>Most common approach is to write a function and tie that to a data store like DynamoDB. You can call that function via Api Gateway. From your client application you can call your api via a rest api.</p><h3>Problem</h3><p>Big promise of serverless is that developers only have to write business logic. And it really helps. However they still need to deal with following issues:</p><p><strong>Authentication</strong> — Yes there are services like Cognito, but they are not really easy to use.</p><p><strong>Client-Server-Communication</strong> — Rest api’s are great but they are not as easy as realtime syncing of client/server data.</p><p><strong>Sorting of client requests</strong> — Biggest problem is that somehow you need to sort requests coming from clients in object level. Think of a wallet app, transactions need to be fed into a SQS Fifo queue or maybe locked in DynamoDB row level. It becomes even more difficult if you need a request/response model and also need to sort these requests.
Organization of a project in terms of source code</p><h3>Solution</h3><p>RBS solves these three major problems by implementing following:</p><p><strong>Authentication</strong> — is built into objects.
<strong>Client-Server-Communication</strong> — Objects have internal state and this state is streamed to clients in realtime.
<strong>Sorting</strong> — Any method request to an object is queued and handled in FIFO manner.</p><h3>Example: A simple wallet</h3><p>The following template.yml defines two methods in a class.</p><pre><code class="language-yml">preAuthorizer: index.preAuthorizer
authorizer: index.authorizer
init: index.init
getState: index.getState
getInstanceId: index.getInstanceId
methods:
    - method: addMoney
      tag: test
      sync: true
      steps:
          - id: addMoney
            
    - method: spendMoney
      tag: test
      sync: true
      steps:
          - id: spendMoney
            handler: index.spendMoneyHandler
          - id: success
          - id: insufficientFunds
            handler: index.handler
      flow:
          - direction:
                - spendMoney
                - success
          - id: gotoInsufficientFunds
            direction:
                - spendMoney
                - insufficientFunds


</code></pre><p>This class definition template yml file creates the following diagram.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>We have two methods we can call from our clients. To call this object first you need to create an RBS SDK instance.</p><pre><code class="language-typescript">this.rbs = RBS.getInstance({
  projectId: &#x27;{RBS_PROJECT_ID}&#x27;
})
</code></pre><p>Let’s get an instance of our WalletB class. We also immediately start listening to its state updates.</p><pre><code class="language-typescript">const co = await this.rbs?.getCloudObject({
  classId: &#x27;WalletB&#x27;
})

co.state.public?.subscribe((publicState: any) =&gt; {
  console.log(&#x27;publicState&#x27;, publicState)
})
</code></pre><p>Now it’s time to call some methods on our wallet instance</p><pre><code class="language-typescript">await co.call({
  method: &#x27;spendMoney&#x27;,
  payload: {
    amount: 10
  }
})
</code></pre><p>That’s it for now. We will dive deeper into cloud object mechanics in upcoming articles.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[CloudObject — A Simple User with Auth — Part 1/3]]></title>
        <id>cloudobject-a-simple-user-with-auth-part-1-3</id>
        <link href="https://rettersoft.github.io/blog/cloudobject-a-simple-user-with-auth-part-1-3"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Let’s create a new class DemoUser.]]></summary>
        <content type="html"><![CDATA[<p>Let’s create a new class DemoUser.</p><p><img src="https://miro.medium.com/max/1400/1*VyrA6eP2VmQTZ4WKL3aUzQ.png" alt="rtbs screenshot"/></p><p>Let’s add a new file called “auth.ts”. We will implement authentication related functions in this file.</p><p><img src="https://miro.medium.com/max/1400/1*hXFJjgjd29Uz7QXuo7ShBA.png" alt="rtbs screenshot"/></p><p>Now let’s start writing our lookupUser function:</p><pre><code class="language-typescript">import CloudObjectsOperator, { Data, StepResponse } from &#x27;./CloudObjects&#x27;

const sdk = new CloudObjectsOperator()

export async function lookupUser(data: Data): Promise&lt;StepResponse&gt; {
    const { success:userFound } = await sdk.getLookUpKey({ key: { name: &#x27;email&#x27;, value: data.method.request.email } })

    if(userFound) {
        data.method.response = {
            statusCode: 403, body: { message: &quot;Email is taken&quot; }
        }
        return data
    }

    return data
}
</code></pre><p>Our request will contain email, so we will use sdk.getLookupKey to check for another instance which might have the same email. Okay we are returning an error but let’s make it more visual in our method. Implement a flow and a second step.</p><p><img src="https://miro.medium.com/max/1400/1*03-6XHfe6UHJQHuOZzN2DQ.png" alt="rtbs screenshot"/></p><p>Why do we add a second step? We don’t have to add it. We can do everything in one step only. But if we separate different logics into different steps we can make it more visual and anybody looking at an execution later will be able to examine what happened very quickly.</p><p>Now add another step to create this user.</p><p><img src="https://miro.medium.com/max/1400/1*bCig2aoebOoToF1WkXbgwA.png" alt="rtbs screenshot"/></p><p>How do we tell the method to go to emailAlreadyTaken step? We use data.nextFlowId field. Like so:</p><p><img src="https://miro.medium.com/max/1400/1*0PY4PPVBDHTjXnQ0fM8kdg.png" alt="rtbs screenshot"/></p><p>We can also move some code to another function:</p><p><img src="https://miro.medium.com/max/1400/1*WbwvtZYqdt7n0L4uZZAESw.png" alt="rtbs screenshot"/></p><p>We have 3 functions. Now let’s see how we create a user.</p><pre><code class="language-typescript">export async function createUser(data: Data): Promise&lt;StepResponse&gt; {

    const { email, name, password } = data.method.request

    await sdk.setLookUpKey({
        key: {
            name: &#x27;email&#x27;,
            value: email
        }
    })

    data.state = {
        ...data.state,
        public: { userId: data.context.instanceId },
        private: {
            email,
            name,
            password
        }
    }
    return data
}
</code></pre><p>We first set email as a lookup value to this instance. Now let’s add another step to generate a token. This token will be used by the client to sign in to rtbs.</p><pre><code class="language-typescript">export async function generateToken(data: Data): Promise&lt;StepResponse&gt; {

    const actionResponse = await sdk.rbsAction({
        name: &#x27;rbs.core.request.GENERATE_CUSTOM_TOKEN&#x27;,
        data: { userId: data.method.context.userId, roleNames: [&#x27;enduser&#x27;] }
    })

    data.method.response = {
        statusCode: 200,
        body: {
            customToken: actionResponse.response.customToken
        }
    }

    return data
}
</code></pre><p>So we need to update our template.</p><p><img src="https://miro.medium.com/max/1400/1*zUUfBaVQ9jPg5CShKZZxQA.png" alt="rtbs screenshot"/></p><p>At this point we have a working signup method. In the next article we will sign in with this user.</p><p>Thanks.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[State of a cloud object]]></title>
        <id>state-of-cloud-object</id>
        <link href="https://rettersoft.github.io/blog/state-of-cloud-object"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Every object has a state. This state is stored within the object. Best practice is to keep the size of this state relatively small. For instance if you are developing a chat application you might hold last 100 messages in state but store the rest in a sortedSet of this object. However we will only talk about state in this article.]]></summary>
        <content type="html"><![CDATA[<p>Every object has a state. This state is stored within the object. Best practice is to keep the size of this state relatively small. For instance if you are developing a chat application you might hold last 100 messages in state but store the rest in a sortedSet of this object. However we will only talk about state in this article.
State object gets streamed to client sdk’s in real time.
State consists of four parts:</p><pre><code class="language-json">{
  &quot;public&quot;: {},
  &quot;private&quot;: {},
  &quot;user&quot;: {
    &quot;userId1&quot;: { }
  },
  &quot;role&quot;: {
    &quot;roleName1&quot;: { }
  }
}
</code></pre><h3>Public</h3><p>Public state can be seen by every client connected.</p><h3>Private</h3><p>Private state doesn’t get streamed to any client. Only server side code (objects methods) can see and edit this state.</p><h3>User</h3><p>User object has userId’s in it. Each userId node contains the data specific for that userId. Only that user is allowed to see that data.</p><p><img src="https://miro.medium.com/max/856/1*z2hPPoc3pmG-RBl_LbM-1g.png" alt="rtbs screenshot"/></p><h3>Role</h3><p>Role state can be seen by anybody who has that role.</p><p><img src="https://miro.medium.com/max/960/1*XS1vUwFlu43E2DxRwQit8Q.png" alt="rtbs screenshot"/></p><h3>What do you do with state?</h3><p>In your server side code you update the state object any way you want. Clients connected to this object will receive updates according to their permission level. It easy straight forward.</p><h3>getState function</h3><p>Clients can either get the state via REST api or they can subscribe to state via sdk.</p><p>If you want to get your state via REST api you can define a delegate function in your template file and customize what part of state you will return to anybody making the call. Below I defined a getState function in index.ts.</p><p><img src="https://miro.medium.com/max/1400/1*_m62mrSZOkuoEopDDOse6Q.png" alt="rtbs screenshot"/></p><p>Below is my getState function which returns my objects private state to any caller. Of course this is pretty unsecure. Don’t do this at home :)</p><pre><code class="language-typescript">export async function getState(data: Data): Promise&lt;Response&gt; {
    return { 
        statusCode: 200, 
        body: {
            ...data.state.private,
        }
    }
}
</code></pre><p>Thanks.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Todo App with CloudObjects — Part 1/3]]></title>
        <id>todo-app-1-3</id>
        <link href="https://rettersoft.github.io/blog/todo-app-1-3"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this article we will create a simple todo class and implement adding an item to it.]]></summary>
        <content type="html"><![CDATA[<h3>In this article we will create a simple todo class and implement adding an item to it.</h3><p>Let’s write a basic todo app. First let’s create an account in rtbs.io and create a class in your account.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Todo App with CloudObjects — Part 2/3]]></title>
        <id>todo-app-2-3</id>
        <link href="https://rettersoft.github.io/blog/todo-app-2-3"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers.]]></summary>
        <content type="html"><![CDATA[<p>Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers. </p><p>However they allow you write stateless functions only. Data and functions are separated like in the early days of computing. rtbs.io is an object oriented approach to serverless cloud.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>I will give AWS specific examples in this article.</p><p>Most common approach is to write a function and tie that to a data store like DynamoDB. You can call that function via Api Gateway. From your client application you can call your api via a rest api.</p><h3>Problem</h3><p>Big promise of serverless is that developers only have to write business logic. And it really helps. However they still need to deal with following issues:</p><p><strong>Authentication</strong> — Yes there are services like Cognito, but they are not really easy to use.</p><p><strong>Client-Server-Communication</strong> — Rest api’s are great but they are not as easy as realtime syncing of client/server data.</p><p><strong>Sorting of client requests</strong> — Biggest problem is that somehow you need to sort requests coming from clients in object level. Think of a wallet app, transactions need to be fed into a SQS Fifo queue or maybe locked in DynamoDB row level. It becomes even more difficult if you need a request/response model and also need to sort these requests.
Organization of a project in terms of source code</p><h3>Solution</h3><p>RBS solves these three major problems by implementing following:</p><p><strong>Authentication</strong> — is built into objects.
<strong>Client-Server-Communication</strong> — Objects have internal state and this state is streamed to clients in realtime.
<strong>Sorting</strong> — Any method request to an object is queued and handled in FIFO manner.</p><h3>Example: A simple wallet</h3><p>The following template.yml defines two methods in a class.</p><pre><code class="language-yml">preAuthorizer: index.preAuthorizer
authorizer: index.authorizer
init: index.init
getState: index.getState
getInstanceId: index.getInstanceId
methods:
    - method: addMoney
      tag: test
      sync: true
      steps:
          - id: addMoney
            
    - method: spendMoney
      tag: test
      sync: true
      steps:
          - id: spendMoney
            handler: index.spendMoneyHandler
          - id: success
          - id: insufficientFunds
            handler: index.handler
      flow:
          - direction:
                - spendMoney
                - success
          - id: gotoInsufficientFunds
            direction:
                - spendMoney
                - insufficientFunds


</code></pre><p>This class definition template yml file creates the following diagram.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>We have two methods we can call from our clients. To call this object first you need to create an RBS SDK instance.</p><pre><code class="language-typescript">this.rbs = RBS.getInstance({
  projectId: &#x27;{RBS_PROJECT_ID}&#x27;
})
</code></pre><p>Let’s get an instance of our WalletB class. We also immediately start listening to its state updates.</p><pre><code class="language-typescript">const co = await this.rbs?.getCloudObject({
  classId: &#x27;WalletB&#x27;
})

co.state.public?.subscribe((publicState: any) =&gt; {
  console.log(&#x27;publicState&#x27;, publicState)
})
</code></pre><p>Now it’s time to call some methods on our wallet instance</p><pre><code class="language-typescript">await co.call({
  method: &#x27;spendMoney&#x27;,
  payload: {
    amount: 10
  }
})
</code></pre><p>That’s it for now. We will dive deeper into cloud object mechanics in upcoming articles.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Todo App with CloudObjects — Part 3/3]]></title>
        <id>todo-app-3-3</id>
        <link href="https://rettersoft.github.io/blog/todo-app-3-3"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers.]]></summary>
        <content type="html"><![CDATA[<p>Cloud providers like AWS, GCP, Azure are next generation machines for writing programs to. Instead of writing containerized apps you can write serverless apps for these new big super computers. </p><p>However they allow you write stateless functions only. Data and functions are separated like in the early days of computing. rtbs.io is an object oriented approach to serverless cloud.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>I will give AWS specific examples in this article.</p><p>Most common approach is to write a function and tie that to a data store like DynamoDB. You can call that function via Api Gateway. From your client application you can call your api via a rest api.</p><h3>Problem</h3><p>Big promise of serverless is that developers only have to write business logic. And it really helps. However they still need to deal with following issues:</p><p><strong>Authentication</strong> — Yes there are services like Cognito, but they are not really easy to use.</p><p><strong>Client-Server-Communication</strong> — Rest api’s are great but they are not as easy as realtime syncing of client/server data.</p><p><strong>Sorting of client requests</strong> — Biggest problem is that somehow you need to sort requests coming from clients in object level. Think of a wallet app, transactions need to be fed into a SQS Fifo queue or maybe locked in DynamoDB row level. It becomes even more difficult if you need a request/response model and also need to sort these requests.
Organization of a project in terms of source code</p><h3>Solution</h3><p>RBS solves these three major problems by implementing following:</p><p><strong>Authentication</strong> — is built into objects.
<strong>Client-Server-Communication</strong> — Objects have internal state and this state is streamed to clients in realtime.
<strong>Sorting</strong> — Any method request to an object is queued and handled in FIFO manner.</p><h3>Example: A simple wallet</h3><p>The following template.yml defines two methods in a class.</p><pre><code class="language-yml">preAuthorizer: index.preAuthorizer
authorizer: index.authorizer
init: index.init
getState: index.getState
getInstanceId: index.getInstanceId
methods:
    - method: addMoney
      tag: test
      sync: true
      steps:
          - id: addMoney
            
    - method: spendMoney
      tag: test
      sync: true
      steps:
          - id: spendMoney
            handler: index.spendMoneyHandler
          - id: success
          - id: insufficientFunds
            handler: index.handler
      flow:
          - direction:
                - spendMoney
                - success
          - id: gotoInsufficientFunds
            direction:
                - spendMoney
                - insufficientFunds


</code></pre><p>This class definition template yml file creates the following diagram.</p><p><img src="http://s.rtbs.io/img/1*Nz9RJzQD_s1dN7d66n6Zsw.png" alt="rtbs screenshot"/></p><p>We have two methods we can call from our clients. To call this object first you need to create an RBS SDK instance.</p><pre><code class="language-typescript">this.rbs = RBS.getInstance({
  projectId: &#x27;{RBS_PROJECT_ID}&#x27;
})
</code></pre><p>Let’s get an instance of our WalletB class. We also immediately start listening to its state updates.</p><pre><code class="language-typescript">const co = await this.rbs?.getCloudObject({
  classId: &#x27;WalletB&#x27;
})

co.state.public?.subscribe((publicState: any) =&gt; {
  console.log(&#x27;publicState&#x27;, publicState)
})
</code></pre><p>Now it’s time to call some methods on our wallet instance</p><pre><code class="language-typescript">await co.call({
  method: &#x27;spendMoney&#x27;,
  payload: {
    amount: 10
  }
})
</code></pre><p>That’s it for now. We will dive deeper into cloud object mechanics in upcoming articles.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>welcome</id>
        <link href="https://rettersoft.github.io/blog/welcome"/>
        <updated>2021-08-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docusaurus blogging features are powered by the blog plugin.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://docusaurus.io/docs/blog">Docusaurus blogging features</a> are powered by the <a href="https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog">blog plugin</a>.</p><p>Simply add Markdown files (or folders) to the <code>blog</code> directory.</p><p>Regular blog authors can be added to <code>authors.yml</code>.</p><p>The blog post date can be extracted from filenames, such as:</p><ul><li><code>2019-05-30-welcome.md</code></li><li><code>2019-05-30-welcome/index.md</code></li></ul><p>A blog post folder can be convenient to co-locate blog post images:</p><p><img src="./docusaurus-plushie-banner.jpeg" alt="Docusaurus Plushie"/></p><p>The blog supports tags as well!</p><p><strong>And if you don&#x27;t want a blog</strong>: just delete this directory, and use <code>blog: false</code> in your Docusaurus config.</p>]]></content>
        <author>
            <name>Baran Baygan</name>
            <uri>https://github.com/baranbaygan</uri>
        </author>
    </entry>
</feed>